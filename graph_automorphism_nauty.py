iso: int = 3
def find_vertex_orbits(nx_graph, graph_name: str):
    print('***NAUTY*** find_vertex_orbits')
    #return [(0, 1), (2,), (3,), (4, 5)]     #good
    #return [(0, 1), (2, 3), (4, 5)]         #bad
    #return [(0,), ( 1, ), (2, ), (3, ), (4, ), (5, )]  # why test
    match graph_name:
        case 'q4':
            #return [(0,), (1, ), (2, ), (3, )] .....adds unescessary angles for 1 and 2
            return [(0,), (3, )]
        case 'q5':
            return [(0,), (2, ), (4, )]
        case 'q6':
            return [(0,), (2, ), (3, ), (5, )]
        case 'e9':
            return [(1, ), (2, ), (3, ), (4, ), (7, ), (8, )]
        case 'q12':
            return [(0,), (2, ), (3, ), (4, ), (5, ), (6, ), (7, ), (8, ), (9, ), (11, )]
        case 'q15':
            return [(0,), (1, ), (2, ), (3, ), (4, ), (5, ), (6, ), (7, ), (8, ), (9, ), (10, ), (11, ), (12, ), (14, )]


def find_edge_orbits(nx_graph, vertex_automorphisms, graph_name: str):
    print('***NAUTY*** find_edge_orbits')
    match graph_name:
        case 'q4':
            return [{(0, 1, 2), (1, 2, 3)}, {(0, 1)}, {(0,2)}, {(1, 3)}, {(2, 3)}]
            #return [([0, 1, 2], [1, 2, 3]), ([0, 1]), ([0, 2]), ([1, 3]), ([2, 3])]
        case 'q5': #MA CC:77-78 (100%)
            return [{(0,1,2), (2,3,4)}, {(1,2,3)}, {(0,1), (3,4), (0,2), (2,4)}, {(1,3), (1,2), (2,3)}]     #CC:67 (100%)
            #return [{(0,1,2), (2,3,4)}, {(1,2,3)}, {(0,1), (3,4)}, {(0,2), (2,4)}, {(1,3)}]                 #CC:83-84 (100%)
            #return [{(0,1,2), (2,3,4)}, {(1,2,3)}, {(0,1), (3,4)}, {(0,2), (2,4)}, {(1,3), (1,2), (2,3)}]   #CC:83-84 (100%)
            #return [{(0,1,2), (2,3,4)}, {(1,2,3)}, {(0,1), (3,4), (0,2), (2,4), (1,3), (1,2), (2,3)}]       # CC:54-58 (78.5%)
        case 'q6': #MA CC:92 [2071] 75%
            if iso == 1:
                return [{(0, 1, 2), (3, 4, 5)}, {(1, 2, 3), (2, 3, 4)}, {(0, 1), (0, 2), (1, 2)}, {(2, 3), (1, 2), (1, 3)}, {(2, 3), (2, 4), (3, 4)}, {(4, 5), (3, 4), (3, 5)}]  #(inner auto) CC:77 [1394]
            elif iso == 2:
                return [{(0, 1, 2), (3, 4, 5)}, {(0, 1), (4, 5)}, {(0, 2), (3, 5)}, {(0,), (5,)}, {(1, 2, 3), (2, 3, 4)}, {(2, 4), (1, 3)}, {(2,), (3,)}]  # (full cf) 61% CC:124 [2358]

            #return [{(0, 1, 2), (3, 4, 5)}, {(0, 1), (4, 5)}, {(0, 2), (3, 5)}, {(1, 2, 3), (2, 3, 4)}, {(2, 4), (1, 3)}] #CC:124 [2096]
            #return [{(0,1,2), (3,4,5)}, {(1,2,3), (2,3,4)}, {(0,1), (0,2)},{(3,5), (4,5)}, {(1,3)}, {(2,4)}]      #CC:77-80 [1394]
            #return [{(0,1,2), (3,4,5)}, {(1,2,3), (2,3,4)}, {(0,1), (0,2)},{(3,5), (4,5)}, {(1,3), (2,4)}]      #CC:104 [1808]
            #return [{(0,1,2), (3,4,5)}, {(1,2,3), (2,3,4)}, {(0,1), (0,2),(3,5), (4,5)}, {(1,3)}, {(2,4)}]      #CC:132-137 (75%)
            #return [{(0,1,2), (3,4,5)}, {(1,2,3), (2,3,4)}, {(0,1)}, {(0,2)}, {(3,5)}, {(4,5)}, {(1,3)}, {(2,4)}] #CC:92

        case 'e9':
            if iso == 1:
                return [{(0, 1, 2), (6, 7, 8)}, {(0, 1), (6, 7)}, {(6, 8), (0, 2)}, {(0, 3, 6)}, {(0, 3), (3, 6)}, {(0, 6)}, {(1, 2), (7, 8)}, {(1,), (7,)}, {(2, 5, 8)}, {(2, 5), (5, 8)}, {(2, 8)}, {(8,), (2,)}, {(3, 4, 5)}, {(3, 4)}, {(3, 5)}, {(3,)}, {(4, 5)}, {(4,)}]
            elif iso == 2:
                return [{(0, 1, 2)}, {(0, 3, 6)}, {(3, 4, 5), (6, 7, 8)}, {(2, 5, 8)}, {(0, 1), (0, 2), (1, 2)}, {(4, 5), (3, 4), (3, 5)}, {(6, 7), (6, 8), (7, 8)}, {(0, 3), (3, 6), (0, 6)}, {(5, 8), (2, 5), (2, 8)}]

        case 'q12': #MA CC:122-124 (25%) [5850-5940]
            if iso == 1:
                return [{(0, 1, 2), (10, 11, 9)}, {(0, 1), (10, 11)}, {(0, 2), (11, 9)}, {(11,), (0,)}, {(1, 2, 3), (10, 8, 9)}, {(1, 3), (10, 8)}, {(7, 8, 9), (2, 3, 4)}, {(7, 9), (2, 4)}, {(2,), (9,)}, {(3, 4, 5), (6, 7, 8)}, {(6, 8), (3, 5)}, {(8,), (3,)}, {(5, 6, 7), (4, 5, 6)}, {(4, 6), (5, 7)}, {(7,), (4,)}, {(6,), (5,)}]
            elif iso == 3:
                return [{(0, 1, 2), (10, 11, 9)}, {(0, 1), (10, 11), (0, 2), (11, 9)}, {(11,), (0,)}, {(1, 2, 3), (10, 8, 9)}, {(1, 3), (10, 8)}, {(7, 8, 9), (2, 3, 4)}, {(7, 9), (2, 4)}, {(2,), (9,)}, {(3, 4, 5), (6, 7, 8)}, {(6, 8), (3, 5)}, {(8,), (3,)}, {(5, 6, 7), (4, 5, 6)}, {(4, 6), (5, 7)}, {(7,), (4,)}, {(6,), (5,)}]
            elif iso == 2:
                return [{(0, 1, 2), (9, 10, 11), (10, 11, 9)}, {(1, 2, 3), (8, 9, 10), (10, 8, 9)}, {(7, 8, 9), (2, 3, 4)}, {(3, 4, 5), (6, 7, 8)}, {(5, 6, 7), (4, 5, 6)}, {(0, 1), (0, 2), (1, 2)}, {(2, 3), (1, 2), (1, 3)}, {(2, 3), (2, 4), (3, 4)}, {(4, 5), (3, 4), (3, 5)}, {(4, 5), (4, 6), (5, 6)}, {(6, 7), (5, 6), (5, 7)}, {(6, 7), (6, 8), (7, 8)}, {(7, 9), (8, 9), (7, 8)}, {(9, 10), (8, 9), (8, 10)}, {(9, 10), (9, 11), (10, 11)}]

            #return [{(0, 1, 2), (10, 11, 9)}, {(1, 2, 3), (10, 8, 9)}, {(2, 3, 4), (7, 8, 9)}, {(3, 4, 5), (6, 7, 8)}, {(4, 5, 6), (5, 6, 7)}
            #        , {(0, 1)}, {(0, 2)}, {(1, 3)}, {(10, 11)}, {(10, 8)}, {(11, 9)}, {(2, 4)}, {(3, 5)}, {(4, 6)}, {(5, 7)}, {(6, 8)}, {(7, 9)}]  #CC:123 (25%)
            #        , {(0, 1), (0, 2)}, {(1, 3)}, {(10, 11), (11, 9)}, {(10, 8)}, {(2, 4)}, {(3, 5)}, {(4, 6)}, {(5, 7)}, {(6, 8)}, {(7, 9)}]      #CC:181 (?%)
            #         , {(0, 1), (0, 2)}, {(10, 11), (11, 9)}, {(1, 3), (10, 8), (2, 4), (3, 5), (4, 6), (5, 7), (6, 8), (7, 9)}]      # CC:123-127 (25 %)

        case 'q15':
            return [{(0, 1, 2), (12, 13, 14)}, {(1, 2, 3), (11, 12, 13)}, {(2, 3, 4), (10, 11, 12)}, {(3, 4, 5), (10, 11, 9)}, {(4, 5, 6), (10, 8, 9)}, {(5, 6, 7), (7, 8, 9)}, {(6, 7, 8)}
                    , {(0, 1)}, {(0, 2)}, {(1, 3)}, {(2, 4)}, {(3, 5)}, {(4, 6)}, {(5, 7)}, {(6, 8)}, {(7, 9)}, {(8, 10)}, {(9, 11)}, {(10, 12)}, {(11, 13)}, {(12, 14)}, {(13, 14)}]

        #1
        #return [{(0, 1), (4, 5)}, {(3, 2)}, {(0, 1, 2), (2, 4, 5)}, {(0, 2), (1, 2), (2, 4), (2, 5)}]   #good
        #return [{(0, 2), (1, 2), (0, 1), (4, 5)}, {(3, 2)}, {(0, 1, 2), (2, 4, 5)}, {(2, 4), (2, 5)}]   #bad
        #return[{(3, 2)}, {(0, 1, 2), (2, 4, 5)}, {(0, 1), (4, 5), (0, 2), (1, 2), (2, 4), (2, 5)}]  # why test



def find_edge_cycle_index(edge_cycle: list, edge: tuple):
    for index, edge_set in enumerate(edge_cycle):
        if edge in edge_set or tuple(reversed(edge)) in edge_set:
            return index
    return -1  # Return -1 if the edge is not found


def find_vertex_index(vertex_cycle, vertex):
    for index, vertex_tuple in enumerate(vertex_cycle):
        if vertex in vertex_tuple:
            return index
    return -1  # Return -1 if the vertex is not found

'''
# Create a NetworkX graph (Example: a triangle graph)
#nx_graph = nx.Graph([(0, 1), (1, 2), (2, 0)])
nx_graph = nx.Graph([(0, 1), (1, 2), (2, 3), (1, 3), (3, 4)])
#nx_graph = nx.Graph([(0, 1), (1, 2), (2, 3), (3, 0)])

#group = get_automorphism_groups(nx_graph)
#print(group)

#cycles: Permutation = select_automorphism(nx_graph)
#print(cycles)
#print(type(cycles))

# Example usage
vertex_orbits = find_vertex_orbits(nx_graph)
print(vertex_orbits)
print(len(vertex_orbits))

edge_orbits = find_edge_orbits(nx_graph, vertex_orbits)
print(edge_orbits)
print(len(edge_orbits))
print(type(edge_orbits))


# Display the graph using matplotlib
plt.figure(figsize=(8, 6))
nx.draw(nx_graph, with_labels=True, font_weight='bold', node_color='skyblue', node_size=700, font_size=18)
plt.show()
'''